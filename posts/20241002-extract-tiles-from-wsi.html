<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Extracting Image Tiles from Annotated Regions in Whole Slide Images: Using Python, Slideflow &amp; OpenSlide</title>
<meta name="generator" content="Org mode">
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<link rel="stylesheet" type="text/css" href="/orgstyle.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
<!-- <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
<link rel="icon" href="spock-favicon.png" type="image/png">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<hr style="border-top: 1px solid black;">
<div class='topnav' style='display: flex; justify-content: space-between; align-items: center;'>
  <a href="/index.html"><h2 style='margin-top: 0; margin-bottom: 0; margin-left:0px;'>Lafith Mattara</h2></a>
  <div class='topnav2' style='color:#cfcaca;'>
    <a href='/blog.html' style='font-weight:bold; font-style:bold;'>Blog </a> / 
    <a href='./LafithCV.pdf' style='font-weight:bold; font-style:bold;'>CV </a>
    <!-- <a href='https://lfzmap.github.io' style='font-weight:bold; font-style:italic;'>&#127793;</a>  -->
  </div>
</div>
<hr style="border-top: 1px solid black;">
</div>
<div id="content">
<header>
<h1 class="title">Extracting Image Tiles from Annotated Regions in Whole Slide Images: Using Python, Slideflow &amp; OpenSlide</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org61e8b28">Slideflow</a></li>
<li><a href="#orgf5302a4">Slideflow + OpenSlide</a></li>
</ul>
</div>
</nav>
<p>
Whole Slide Images (WSIs) are increasingly used in digital pathology to provide high-resolution representations of tissue samples. Annotations within these images are crucial for identifying areas of interest for further analysis. This post goes through the process of extracting image tiles from annotated regions in WSIs using Slideflow and OpenSlide. The extracted tile dataset can be used for deep learning tasks, such as tile classification.
</p>

<p>
<b>Prerequisites</b>
</p>
<ol class="org-ol">
<li><a href="https://www.python.org/downloads/">Python</a></li>
<li><a href="https://slideflow.dev/installation/">Slideflow</a></li>
<li><a href="https://openslide.org/download/">OpenSlide</a></li>
<li><a href="https://pypi.org/project/openslide-python/">Openslide-Python</a></li>
</ol>

<div id="outline-container-org61e8b28" class="outline-2">
<h2 id="org61e8b28">Slideflow</h2>
<div class="outline-text-2" id="text-org61e8b28">
<p>
Since we are using Slideflow library the WSIs should be inside a folder named <b>slides,</b> with a subfolder <b>rois</b> containing annotation files. Annotation files should be in the CSV format described in the documentation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> os
<span class="org-keyword">import</span> shutil
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> multiprocessing
<span class="org-keyword">import</span> slideflow <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">.ndpi wsis require libvips</span>
<span class="org-variable-name">os.environ</span>[<span class="org-string">"SF_SLIDE_BACKEND"</span>] = <span class="org-string">"libvips"</span>

<span class="org-variable-name">data_dir</span> = <span class="org-string">"./data"</span>
<span class="org-variable-name">proj_dest</span> = <span class="org-string">"sf_proj"</span>
<span class="org-variable-name">tile_size</span>=224
<span class="org-variable-name">mag</span> = <span class="org-string">"22.1x"</span>
<span class="org-variable-name">tile_data</span> = f<span class="org-string">"tile_df_{mag}.csv"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">remove a slideflow project if already exists</span>
<span class="org-keyword">if</span> os.path.exists(os.path.join(data_dir,proj_dest)):
    shutil.rmtree(os.path.join(data_dir,proj_dest))

<span class="org-comment-delimiter"># </span><span class="org-comment">create a slideflow project</span>
<span class="org-variable-name">sf_project</span> = sf.create_project(
    root=os.path.join(data_dir,proj_dest),
    slides=os.path.join(data_dir,<span class="org-string">"slides"</span>))

<span class="org-comment-delimiter"># </span><span class="org-comment">specify tile size and magnification level</span>
<span class="org-variable-name">dataset</span> = sf_project.dataset(
    tile_px=tile_size,
    tile_um=mag)

<span class="org-comment-delimiter"># </span><span class="org-comment">extract dataframe with tile locations and labels</span>
<span class="org-variable-name">df</span> = dataset.get_tile_dataframe(roi_method=<span class="org-string">'inside'</span>)
df.to_csv(os.path.join(data_dir,tile_data), sep=<span class="org-string">','</span>, index=<span class="org-constant">False</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">extract tiles as .png with reinhard normalization</span>
<span class="org-variable-name">_</span> = dataset.extract_tiles(
    save_tiles=<span class="org-constant">True</span>,
    roi_method=<span class="org-string">'inside'</span>,
    img_format=<span class="org-string">'png'</span>,
    randomize_origin = <span class="org-constant">True</span>,
    num_threads=multiprocessing.cpu_count()-2,
    <span class="org-comment-delimiter"># </span><span class="org-comment">max_tiles=1000,</span>
    skip_extracted=<span class="org-constant">False</span>,
    report=<span class="org-constant">True</span>,
    normalizer=<span class="org-string">"reinhard"</span>)
</pre>
</div>
<p>
Above can be used to extract all tiles from each WSI in the slides folder.
</p>
</div>
</div>

<div id="outline-container-orgf5302a4" class="outline-2">
<h2 id="orgf5302a4">Slideflow + OpenSlide</h2>
<div class="outline-text-2" id="text-orgf5302a4">
<p>
I wanted to save the tiles into different rois/labels. So in this section I am using OpenSlide to extract tiles from the tile dataframe generated using Slideflow.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> os
<span class="org-keyword">import</span> shutil
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> multiprocessing
<span class="org-keyword">import</span> slideflow <span class="org-keyword">as</span> sf
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> partial
<span class="org-keyword">import</span> time
<span class="org-keyword">from</span> openslide <span class="org-keyword">import</span> open_slide
<span class="org-keyword">from</span> openslide.deepzoom <span class="org-keyword">import</span> DeepZoomGenerator
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> PIL <span class="org-keyword">import</span> Image

<span class="org-variable-name">os.environ</span>[<span class="org-string">"SF_SLIDE_BACKEND"</span>] = <span class="org-string">"libvips"</span>
<span class="org-variable-name">os.environ</span>[<span class="org-string">"SF_BACKEND"</span>] = <span class="org-string">"torch"</span>

<span class="org-variable-name">data_dir</span> = <span class="org-string">"./"</span>
<span class="org-variable-name">proj_dest</span> = <span class="org-string">"sf_proj"</span>
<span class="org-variable-name">tile_dest</span> = <span class="org-string">"tiles"</span>
<span class="org-variable-name">tile_size</span>=224
<span class="org-variable-name">mag</span> = <span class="org-string">"22.1x"</span>
<span class="org-variable-name">level</span>=1
<span class="org-variable-name">tile_data</span> = f<span class="org-string">"tile_data_{mag}.csv"</span>
</pre>
</div>

<p>
Following function uses OpenSlide for reading WSI file &amp; DeepZoomGenerator for tile extraction.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">process_slide</span>(slide_id, df, data_dir, tile_fd, level):
    <span class="org-variable-name">start_time</span> = time.time()
    <span class="org-variable-name">slide_df</span> = df[df[<span class="org-string">'slide'</span>] == slide_id]
    <span class="org-keyword">print</span>(f<span class="org-string">"Starting to process slide: {slide_id}, shape: {slide_df.shape}"</span>)
    <span class="org-variable-name">slide_path</span> = os.path.join(data_dir, <span class="org-string">"slides"</span>, f<span class="org-string">"{slide_id}.ndpi"</span>)
    <span class="org-variable-name">slide</span> = open_slide(slide_path)
    <span class="org-variable-name">tiles</span> = DeepZoomGenerator(slide, tile_size=224, overlap=0, limit_bounds=<span class="org-constant">False</span>)
    <span class="org-keyword">print</span>(<span class="org-string">"extracting from level "</span>, level)
    <span class="org-variable-name">new_level</span> = tiles.level_count - level - 1
    <span class="org-variable-name">M</span> = slide_df.shape[0]
    
    <span class="org-variable-name">tiles_processed</span> = 0
    <span class="org-keyword">for</span> _, row <span class="org-keyword">in</span> slide_df.iterrows():
        <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> = row[<span class="org-string">'grid_x'</span>], row[<span class="org-string">'grid_y'</span>]
        <span class="org-variable-name">label</span> = row[<span class="org-string">'label'</span>]
        os.makedirs(os.path.join(data_dir, tile_fd, label), exist_ok=<span class="org-constant">True</span>)
        
        <span class="org-variable-name">tile</span> = tiles.get_tile(new_level, (x, y))
        <span class="org-variable-name">tile_RGB</span> = tile.convert(<span class="org-string">'RGB'</span>)
        <span class="org-variable-name">tile</span> = np.array(tile_RGB)
        
        <span class="org-keyword">if</span> tile.mean() &lt; 230 <span class="org-keyword">and</span> tile.std() &gt; 15:
            <span class="org-variable-name">tile_id</span> = f<span class="org-string">"{slide_id}_{x}_{y}"</span>
            <span class="org-variable-name">im</span> = Image.fromarray(tile)
            im.save(os.path.join(data_dir, tile_fd, label, f<span class="org-string">"{tile_id}.png"</span>))
        <span class="org-variable-name">tiles_processed</span> += 1
        
        <span class="org-keyword">if</span> tiles_processed % 10000 == 0:
            <span class="org-keyword">print</span>(f<span class="org-string">"Slide {slide_id}: Processed {tiles_processed}/{M} tiles"</span>)

    <span class="org-variable-name">end_time</span> = time.time()
    <span class="org-variable-name">processing_time</span> = end_time - start_time
    <span class="org-keyword">print</span>(f<span class="org-string">"Finished processing slide: {slide_id}"</span>)
    <span class="org-keyword">print</span>(f<span class="org-string">"Total tiles processed for slide {slide_id}: {tiles_processed}"</span>)
    <span class="org-keyword">print</span>(f<span class="org-string">"Time taken to process slide {slide_id}: {processing_time:.2f} seconds"</span>)
    <span class="org-keyword">return</span> slide_id, tiles_processed, processing_time
</pre>
</div>

<p>
Let's create the Slideflow project, generate the tile dataframe and use multiprocessing to distribute the workload across multiple CPU cores.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">if</span> os.path.exists(os.path.join(data_dir,proj_dest)):
    shutil.rmtree(os.path.join(data_dir,proj_dest))

<span class="org-variable-name">sf_project</span> = sf.create_project(
    root=os.path.join(data_dir,proj_dest),
    slides=os.path.join(data_dir,<span class="org-string">"slides"</span>))

<span class="org-variable-name">dataset</span> = sf_project.dataset(
    tile_px=tile_size,
    tile_um=mag)

<span class="org-variable-name">df</span> = dataset.get_tile_dataframe(roi_method=<span class="org-string">'inside'</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">df.to_csv(os.path.join(data_dir,tile_data), sep=',', index=False)</span>

<span class="org-variable-name">slide_ids</span> = <span class="org-builtin">list</span>(<span class="org-builtin">set</span>(df[<span class="org-string">'slide'</span>].tolist()))
<span class="org-variable-name">N</span> = <span class="org-builtin">len</span>(slide_ids)
<span class="org-keyword">print</span>(f<span class="org-string">"Total number of slides: {N}"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">Create a partial function with fixed arguments</span>
<span class="org-variable-name">process_slide_partial</span> = partial(process_slide, df=df, data_dir=data_dir, tile_fd=tile_dest,level=level)

<span class="org-comment-delimiter"># </span><span class="org-comment">Use all available CPU cores except one</span>
<span class="org-variable-name">num_processes</span> = multiprocessing.cpu_count()-2
<span class="org-keyword">print</span>(f<span class="org-string">"Using {num_processes} processes"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">Create a pool of workers</span>
<span class="org-variable-name">start_time</span> = time.time()
<span class="org-keyword">with</span> multiprocessing.Pool(processes=num_processes) <span class="org-keyword">as</span> pool:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Map the work to the pool</span>
    <span class="org-variable-name">results</span> = pool.<span class="org-builtin">map</span>(process_slide_partial, slide_ids)

<span class="org-variable-name">end_time</span> = time.time()
<span class="org-variable-name">total_processing_time</span> = end_time - start_time
<span class="org-variable-name">total_tiles_processed</span> = <span class="org-builtin">sum</span>(result[1] <span class="org-keyword">for</span> result <span class="org-keyword">in</span> results)

<span class="org-keyword">print</span>(<span class="org-string">"\nProcessing complete."</span>)
<span class="org-keyword">print</span>(f<span class="org-string">"Total slides processed: {N}"</span>)
<span class="org-keyword">print</span>(f<span class="org-string">"Total tiles processed: {total_tiles_processed}"</span>)
<span class="org-keyword">print</span>(f<span class="org-string">"Total processing time: {total_processing_time:.2f} seconds"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">Print summary for each slide</span>
<span class="org-keyword">print</span>(<span class="org-string">"\nPer-slide summary:"</span>)
<span class="org-keyword">for</span> slide_id, tiles_processed, processing_time <span class="org-keyword">in</span> results:
    <span class="org-keyword">print</span>(f<span class="org-string">"Slide {slide_id}: {tiles_processed} tiles, {processing_time:.2f} seconds"</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-10-02 Wed 00:00</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>
</div>
</body>
</html>
